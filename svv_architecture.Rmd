---
author: Collin McNeil
output: html_document
---

# App Architecture Guide: Understanding the SYNGAP1 Variant Viewer

## Table of Contents
1. [Big Picture Overview](#big-picture-overview)
2. [Design Philosophy](#design-philosophy)
3. [Data Flow Diagram](#data-flow-diagram)
4. [Component Breakdown](#component-breakdown)
5. [Key Design Decisions](#key-design-decisions)
6. [Development Timeline (How the App Was Built)](#development-timeline)
7. [Common Patterns Used](#common-patterns-used)

---

## Big Picture Overview

### What Problem Does This App Solve?

**Problem:**
Clinical geneticists have identified 153 SYNGAP1 gene variants across patient populations, but:
- Variant data is scattered across spreadsheets
- Hard to visualize variant locations on the gene
- No easy way to find variants with research resources (biosamples, cell lines, mouse models)
- cDNA notation is relative to transcript, but visualization requires genome coordinates

**Solution:**
An interactive web app that:
1. Displays all variants on an actual genome browser (IGV)
2. Groups variants by type (missense, nonsense, frameshift, etc.)
3. Filters by available research resources
4. Automatically converts cDNA coordinates to genome positions
5. Runs in any web browser (no installation for end users)

---

## Design Philosophy

### Core Principles That Guided Development

#### 1. **Separation of Concerns**
```
DATA LAYER       â†’ Load, parse, transform, cache
BUSINESS LOGIC   â†’ Filter, format, compute
PRESENTATION     â†’ Display, interact, visualize
```

**Why:** Each layer can be modified independently. Data changes don't break UI. UI redesign doesn't affect data processing.

#### 2. **Performance Through Preprocessing**
```
Do expensive work ONCE at startup
   â†“
   Parse variants
   Query API
   Cache results
   Format data
   â†“
User interactions are INSTANT
```

**Why:** Users don't wait for data processing during interactions. App feels responsive.

#### 3. **Reactive Programming**
```
User changes filter
   â†“ (automatic)
Data re-filtered
   â†“ (automatic)
UI updates
   â†“ (automatic)
Tracks refresh
```

**Why:** No manual update logic. No bugs from forgetting to update something. Declarative code.

#### 4. **Fail Gracefully**
```
Variant has no coordinate? â†’ Skip it, continue
API call fails? â†’ Return NA, don't crash
Filter removes all data? â†’ Show empty track, explain
```

**Why:** Real-world data is messy. App should handle edge cases without breaking.

#### 5. **Cache Everything Expensive**
```
Ensembl API calls â†’ Cached to disk permanently (coordinates never change)
ClinVar API calls â†’ Cached to disk with 7-day expiry (submissions do change)
Parsed data       â†’ Computed once (session)
Filtered data     â†’ Reactive (auto-cached)
```

**Why:** 150x performance improvement for Ensembl lookups. ClinVar stays current without a manual re-download. Works offline between refreshes. Reduces external API load.

---

## Data Flow Diagram

### Startup Sequence
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ APP STARTUP (Happens Once)                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. Load Libraries
   â”œâ”€ shiny, igvShiny, dplyr, stringr, httr, jsonlite, memoise, cachem, shinyWidgets
   â””â”€ Why: Each provides specific functionality

1B. Fetch ClinVar Data (NCBI E-utilities)
   â”œâ”€ Check cache/clinvar/last_updated.txt
   â”œâ”€ If cache < 7 days old â†’ load clinvar_data.rds instantly
   â”œâ”€ Otherwise â†’ esearch SYNGAP1[gene] â†’ esummary in batches of 200
   â”œâ”€ Save to cache/clinvar/ with timestamp
   â””â”€ Fallback: stale cache if fetch fails; empty frame if no cache at all

2. Load CSV Data (updatedCitizen191.csv)
   â”œâ”€ 153 variants Ã— 33 columns
   â””â”€ stringsAsFactors = FALSE for flexibility

3. Clean Variant Types
   â”œâ”€ "missense VUS" â†’ "missense-VUS"
   â”œâ”€ "frameshift deletion" â†’ "frameshift"  
   â””â”€ Ensures consistent naming

4. Extract cDNA Coordinates
   â”œâ”€ "c.333del" â†’ 333
   â”œâ”€ "c.190_200del" â†’ 190
   â””â”€ Uses regex parsing

5. Convert Coordinates to Genome Positions
   â”œâ”€ Query Ensembl API (with permanent disk cache)
   â”œâ”€ cDNA 333 â†’ chr6:33,425,796
   â”œâ”€ First run: 143 API calls (~40 sec)
   â””â”€ Later runs: 143 cache reads (~0.3 sec)

6. Format Protein Changes
   â”œâ”€ "p.R135X" â†’ "Arg135ter"
   â””â”€ Three-letter codes more readable

7. Merge Everything
   â”œâ”€ Original data + coordinates + formatted names
   â””â”€ Complete dataset ready for visualization

8. Start Web Server
   â”œâ”€ Initialize UI
   â”œâ”€ Initialize IGV browser
   â””â”€ Wait for user interaction

First-run total: ~70â€“120 seconds (ClinVar fetch ~30â€“60 sec + Ensembl ~40â€“60 sec)
Subsequent runs: < 2 seconds (both caches warm)
```

### User Interaction Sequence
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ USER INTERACTION (Reactive)                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Scenario 1: User clicks "missense" button
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. observeEvent fires
2. Update added_tracks state (missense = TRUE)
3. Get filtered_data() (respects any active filters)
4. Filter for variant.type == "missense"
5. Convert to GFF3 format
6. Load track into IGV
7. Center view on SYNGAP1 gene
8. Track appears on screen

Scenario 2: User clicks "ClinVar" button
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. observeEvent fires
2. Set clinvar_track_added(TRUE)
3. Read current slider value (input$clinvar_size_kb), default 100 KB
4. Call create_clinvar_gff3_data(clinvar_data, max_size_kb = 100)
   â”œâ”€ Filter out variants with no GRCh38 coordinates
   â”œâ”€ Filter out variants whose span > 100 KB
   â””â”€ Format remaining variants as GFF3
5. Load teal ClinVar track into IGV
6. Center view on SYNGAP1 gene
7. Track appears on screen

Scenario 3: User moves ClinVar size slider to 10 KB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. observeEvent(input$clinvar_size_kb) fires
2. Check clinvar_track_added() â€” TRUE, so continue
3. Re-call create_clinvar_gff3_data(clinvar_data, max_size_kb = 10)
   â””â”€ Fewer variants pass the span filter
4. Reload ClinVar track (replaces existing track, no flicker)
5. Track updates instantly to show only variants â‰¤ 10 KB

Scenario 4: User checks "Has biorepository samples"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Checkbox input changes
2. filtered_data() reactive recalculates
   â”œâ”€ Start with all variants
   â”œâ”€ Filter: biorepository column has data
   â””â”€ Return subset
3. trackButtons UI regenerates (different variant types available)
4. observeEvent for filtered_data() fires
5. All visible internal tracks reload with filtered data
6. IGV updates (some variants disappear)
7. ClinVar track is unaffected (independent of these filters)

Scenario 5: User checks "Cell line available" too
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Second checkbox changes
2. filtered_data() reactive recalculates again
   â”œâ”€ Start with all variants
   â”œâ”€ Filter: biorepository column has data (AND)
   â”œâ”€ Filter: iPSC.line column has data (AND)
   â””â”€ Return smaller subset (intersection)
3. Tracks reload with even fewer variants
4. UI shows only variants with BOTH resources
```

---

## Component Breakdown

### Layer 1: Data Processing

**Purpose:** Transform raw CSV into visualization-ready format; fetch and cache external reference data

**Components:**

1. **ClinVar Fetcher** (`fetch_clinvar_ids`, `fetch_clinvar_summaries`, `load_clinvar_data`)
   - Input: NCBI E-utilities API (esearch + esummary)
   - Output: `clinvar_data` data frame (~1,900 variants with GRCh38 coordinates)
   - Cache: `cache/clinvar/clinvar_data.rds` â€” expires after 7 days
   - Why: Keeps ClinVar reference data current without manual updates

2. **Amino Acid Converter** (`swap_one_letter_to_three_letter`)
   - Input: `"R135X"`
   - Output: `"Arg135ter"`
   - Why: Readability for biologists

3. **Coordinate Extractor** (`extract_cDNA_coordinate`)
   - Input: `"c.333del"`
   - Output: `333`
   - Why: Need numeric value for API query

4. **API Client** (`get_genome_positions_function`)
   - Input: cDNA coordinate `333`
   - Output: `list(seqid="chr6", start=33425796, end=33425796)`
   - Why: IGV needs genome coordinates, not cDNA

5. **Cache Wrapper** (`memoise`)
   - Wraps: `get_genome_positions_function`
   - Effect: Saves results to disk permanently, reads from disk on subsequent calls
   - Why: 150x performance boost, offline capability

6. **Data Loader**
   - Reads CSV
   - Normalizes variant types
   - Extracts coordinates
   - Queries API (or cache)
   - Merges results
   - Creates complete dataset

### Layer 2: User Interface

**Purpose:** Visual layout and controls

**Components:**

1. **Title Bar**
   - Shows app name
   - Professional appearance

2. **Sidebar Panel**
   - Dynamic variant type buttons (generated by server)
   - Static ClinVar track button (below a divider)
   - Log-spaced size filter slider for ClinVar (1â€“50,000 KB, default 100 KB)
   - Three research asset filter checkboxes
   - Compact width (30% of screen)

3. **Main Panel**
   - IGV browser widget
   - Large display area (70% of screen)
   - 700px height for multiple tracks

4. **Footer**
   - Citation for igvShiny tool
   - Centered, small font

**Layout Choice:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         SYNGAP1 Variant Viewer         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              â”‚                         â”‚
â”‚  [missense]  â”‚                         â”‚
â”‚  [nonsense]  â”‚      IGV Browser        â”‚
â”‚  [frameshift]â”‚      (Genome View)      â”‚
â”‚  ...         â”‚                         â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                         â”‚
â”‚  [ClinVar]   â”‚                         â”‚
â”‚  |~~~size~~| â”‚                         â”‚
â”‚              â”‚                         â”‚
â”‚  â–¡ Biorepository                       â”‚
â”‚  â–¡ Cell line â”‚                         â”‚
â”‚  â–¡ Mouse lineâ”‚                         â”‚
â”‚              â”‚                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  30% width         70% width
```

### Layer 3: Server Logic

**Purpose:** Reactive programming that connects UI to data

**Components:**

1. **Internal Track State Manager** (`added_tracks`)
   - Tracks which variant-type buttons user has clicked
   - Persists across filter changes
   - Type: `reactiveVal(list())`

2. **ClinVar Track State Manager** (`clinvar_track_added`)
   - Separate flag for whether the ClinVar track is currently displayed
   - Prevents the size slider observer from firing before the track exists
   - Type: `reactiveVal(FALSE)`

3. **Data Filter** (`filtered_data`)
   - Reactive expression
   - Recomputes when any filter checkbox changes
   - Returns: Subset of variant_data matching all active filters
   - Note: Does not affect ClinVar data (independent reference dataset)

4. **Button Generator** (`output$trackButtons`)
   - Reactive UI
   - Creates buttons based on filtered variant types
   - Updates when filters change

5. **Internal Track Loader** (`observe` with button events)
   - Listens for variant-type button clicks
   - Converts data to GFF3 format
   - Loads track into IGV
   - Handles empty data gracefully

6. **ClinVar Track Loader** (`observeEvent(input$addTrack_clinvar)`)
   - Listens for ClinVar button click
   - Sets `clinvar_track_added(TRUE)`
   - Calls `create_clinvar_gff3_data()` with current slider value
   - Loads teal ClinVar track into IGV

7. **ClinVar Size Slider Handler** (`observeEvent(input$clinvar_size_kb)`)
   - Fires when user moves the size filter slider
   - No-op if `clinvar_track_added()` is FALSE (track not yet displayed)
   - Re-builds GFF3 with new KB threshold and reloads track live

8. **Track Updater** (`observeEvent(filtered_data())`)
   - Watches for filter changes
   - Reloads all visible internal tracks with new filtered data
   - Keeps display in sync with filters

9. **IGV Initializer** (`output$igvShiny_0`)
   - Sets up genome browser on startup
   - Configures genome (hg38)
   - Sets initial view (SYNGAP1)
   - Starts with no tracks

---

## Key Design Decisions

### Decision 1: When to Process Data?

**Options:**
- A) Process data when user requests it (lazy loading)
- B) Process all data at startup (eager loading)

**Chosen: B (Eager Loading)**

**Rationale:**
- Dataset is small (153 variants)
- Startup delay acceptable (~1 second with cache)
- User interactions must be instant
- Simpler code (no loading states)
- Better UX (no waiting during use)

**Trade-off:** Longer startup vs instant interactions â†’ Choose instant interactions

---

### Decision 2: How to Handle API Rate Limits?

**Options:**
- A) Make API calls on-demand as user clicks
- B) Prefetch all coordinates at startup
- C) Cache results permanently to disk

**Chosen: B + C (Prefetch + Permanent Cache)**

**Rationale:**
- 143 coordinates under 15 req/sec limit
- First run builds permanent cache
- Later runs use cache (offline capable)
- No network dependency after first run
- Works behind firewalls

**Trade-off:** First run delay vs long-term reliability â†’ Choose reliability

---

### Decision 3: What Happens When Filters Remove All Data?

**Options:**
- A) Hide the track completely
- B) Show empty track with message
- C) Disable the button

**Chosen: B (Show Empty Track)**

**Rationale:**
- User feedback (track exists, just filtered out)
- Consistent behavior (all clicks do something)
- Less confusing than disappearing tracks
- Easy to understand why track is empty

**Trade-off:** Visual clutter vs clarity â†’ Choose clarity

---

### Decision 4: How to Structure Filter Logic?

**Options:**
- A) OR logic (any filter matches)
- B) AND logic (all filters match)
- C) Complex boolean logic

**Chosen: B (AND Logic)**

**Rationale:**
- "Show variants with biorepository AND cell line"
- Natural interpretation
- Most useful for research planning
- Simple to implement
- Easy to explain to users

**Trade-off:** Flexibility vs simplicity â†’ Choose simplicity

---

### Decision 5: Where to Store Genome Positions?

**Options:**
- A) In CSV file
- B) Query API each time
- C) Cache in memory
- D) Cache on disk permanently

**Chosen: D (Disk Cache) with path to migrate to A**

**Current Approach:**
```
CSV â†’ Extract coords â†’ Check cache â†’ (API if needed) â†’ Display
```

**Better Future Approach:**
```
Enhanced CSV (with positions) â†’ Display
```

**Rationale:**
- Current: Good enough, works now
- Future: Simpler, faster, more reliable
- Migration path: Extract cache â†’ CSV â†’ Remove API code

---

## Development Timeline (How the App Was Built)

### Phase 1: Prototype (The "desktop" File)
```
Goal: Prove concept
Approach: Hardcode everything
Result: 160 hardcoded positions, single track
Learning: IGV integration works!
```

**Code:**
```r
startPathogenic <- c(33420307, 33420332, ...)  # 160 positions
loadBedTrack(..., tbl=tbl.pathogenic, color="red")
```

**Limitations:**
- Can't add new variants without editing code
- No filtering
- No variant type distinction
- Not maintainable

### Phase 2: Data-Driven Design
```
Goal: Load from CSV
Approach: Read updatedCitizen191.csv
Result: Dynamic variant loading
Learning: Need coordinate conversion!
```

**Challenge:** CSV has cDNA coordinates, IGV needs genome coordinates

**Solution:** Ensembl REST API

### Phase 3: API Integration
```
Goal: Convert coordinates automatically
Approach: Query Ensembl API
Result: Working but slow (40 seconds startup)
Learning: Need caching!
```

**Problem:**
```
143 variants Ã— 300ms per API call = 42,900ms = 43 seconds
```

**Unacceptable for production app**

### Phase 4: Performance Optimization
```
Goal: Fast loading
Approach: Memoization with disk cache
Result: 0.3 second startup after first run
Learning: Cache is essential!
```

**Implementation:**
```r
get_genome_positions <- memoise(get_genome_positions_function,
                                cache = cachem::cache_disk("cache/genome_positions"))
```

**Performance:**
```
Before: 43 seconds every time
After:  43 seconds first time, 0.3 seconds always after
Improvement: 150x speedup for typical usage
```

### Phase 5: Rich UI Features
```
Goal: Multiple variant types, filtering
Approach: Dynamic buttons, reactive filters
Result: Professional research tool
Learning: Reactive programming is powerful!
```

**Added:**
- Color-coded variant types
- Dynamic button generation
- Research asset filters
- Graceful empty state handling
- Track updates on filter changes

### Phase 6: Polish & Documentation
```
Goal: Production-ready code
Approach: Comments, error handling, citation
Result: Maintainable, documented application
Learning: Documentation is essential!
```

### Phase 7: ClinVar Integration & Size Filter
```
Goal: Add live ClinVar reference data alongside internal variants
Approach: NCBI E-utilities API with time-limited cache
Result: Toggleable ClinVar track with log-spaced size filter slider
Learning: Two caches with different lifetimes need different strategies!
```

**Added:**
- Live ClinVar fetch via NCBI esearch + esummary (batched, rate-limited)
- 7-day time-limited cache (`cache/clinvar/`) with stale-cache fallback
- `create_clinvar_gff3_data()` with `max_size_kb` parameter
- Static ClinVar button (separate from dynamic variant-type loop)
- `clinvar_track_added` state flag to gate the slider observer
- `shinyWidgets::sliderTextInput()` with log-spaced stops (1â€“50,000 KB)
- Live track reload on slider change

---

## Common Patterns Used

### Pattern 1: Memoization for Expensive Operations
```r
expensive_function <- function(x) {
  # Complex calculation or API call
  Sys.sleep(0.3)  # Simulating delay
  return(x * 2)
}

# Wrap with memoization
cached_function <- memoise(expensive_function)

# First call: Slow (0.3 seconds)
result1 <- cached_function(5)

# Second call: Fast (< 0.001 seconds)
result2 <- cached_function(5)
```

**When to use:** Expensive computations with stable results

---

### Pattern 2: Reactive Expression for Derived Data
```r
# Reactive expression (automatically updates)
filtered_data <- reactive({
  data <- original_data
  if (input$checkbox) {
    data <- data %>% filter(...)
  }
  data
})

# Use in outputs/observers
output$plot <- renderPlot({
  plot(filtered_data())  # Auto-updates when checkbox changes
})
```

**When to use:** Data that depends on user inputs and is used in multiple places

---

### Pattern 3: Closure to Avoid Variable Capture
```r
# WRONG - all observers share same 'type'
for (type in types) {
  observeEvent(input[[type]], {
    print(type)  # Always prints last type!
  })
}

# RIGHT - each observer gets own 't'
for (type in types) {
  local({
    t <- type  # Capture in local scope
    observeEvent(input[[t]], {
      print(t)  # Prints correct type
    })
  })
}
```

**When to use:** Observers in loops

---

### Pattern 4: Graceful Degradation
```r
result <- tryCatch({
  expensive_operation()
}, error = function(e) {
  # Return sensible default instead of crashing
  return(list(seqid = "chr6", start = NA, end = NA))
})
```

**When to use:** External dependencies, network calls, user data

---

### Pattern 5: Separate Validation from Processing
```r
# Validation wrapper
extract_protein_change <- function(protein_change) {
  if (is.na(protein_change) || protein_change == "") {
    return(protein_change)  # Handle bad input
  }
  swap_one_letter_to_three_letter(protein_change)  # Do work
}

# Processing function (assumes valid input)
swap_one_letter_to_three_letter <- function(protein_change_str) {
  # No validation needed - wrapper handles it
  # Pure transformation logic
}
```

**When to use:** Complex data transformations with edge cases

---

## Summary: The Full Picture

```
                    SYNGAP1 Variant Viewer
                           â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                                     â”‚
    DATA LAYER                           UI LAYER
        â”‚                                     â”‚
   Load CSV â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  Display Controls
   Parse Variants                       Show IGV Browser
   Query Ensembl (cached!) â†â”€â”€â”€â”€â”€â”€â”€â”€  User Clicks Button
   Fetch ClinVar (7-day cache!)         User Checks Filter
   Format Data              â†â”€â”€â”€â”€â”€â”€â”€â”€  User Moves Slider
        â”‚                                     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
                    REACTIVE LAYER
                   (Shiny Server)
                           â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                  â”‚                  â”‚
   Filter Data      Generate UI        Load Tracks
   (reactive())   (renderUI())    (observeEvent())
        â”‚                  â”‚                  â”‚
        â”‚                  â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                  â”‚  Internal tracks       ClinVar track
        â”‚                  â”‚  (filtered by          (filtered by
        â”‚                  â”‚   checkboxes)           size slider)
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
                    User sees updated view
                    (tracks, filters, data)
```

**Key Insight:** 
The app maintains two parallel data pipelines: internal variant data flows from CSV â†’ Ensembl API â†’ reactive filter â†’ GFF3 â†’ IGV, while ClinVar data flows from NCBI API â†’ 7-day cache â†’ size filter â†’ GFF3 â†’ IGV. Both pipelines share the same IGV browser but are controlled independently â€” internal tracks respond to research-asset checkboxes, while the ClinVar track responds only to its own button and size slider.

**Success Criteria:**
âœ… Fast (< 1 second load time after first run)
âœ… Reliable (handles missing data gracefully)
âœ… Useful (filters help researchers find variants)
âœ… Maintainable (well-documented, modular code)
âœ… Scalable (can handle more variants/filters)

---

## Next Steps for Understanding

1. **Read the commented code** (`svv_app_v2_1.R`)
   - Start at top, read section by section
   - Each function has detailed explanation

2. **Run the app** and watch the console
   - See API calls on first run
   - Notice instant load on second run
   - Try filters, observe reactive updates

3. **Experiment with modifications**
   - Add a new filter
   - Change color scheme
   - Add a download button

4. **Study the reactive flow**
   - Open RStudio debugger
   - Set breakpoints in observers
   - Watch values change as you interact

5. **Review design decisions**
   - Understand why each choice was made
   - Consider alternatives
   - Think about trade-offs

Good luck! ğŸ§¬